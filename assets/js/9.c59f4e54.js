(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{528:function(s,n,e){s.exports=e.p+"assets/img/JsonPatchEncrypt.c71133de.png"},529:function(s,n,e){s.exports=e.p+"assets/img/StructMemeryLayout.9bc5d1f7.png"},530:function(s,n,e){s.exports=e.p+"assets/img/json2binary.d5b6bc51.png"},531:function(s,n,e){s.exports=e.p+"assets/img/BinaryPatchStringTable.c724e6ba.png"},552:function(s,n,e){"use strict";e.r(n);var a=e(6),t=Object(a.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("二进制补丁的主要目的是优化JSON补丁，所以先从JSON补丁说起。")]),s._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),a("p",[s._v("OCRunner 最初的时候是打算只使用 Json 补丁的，可当在我能力范围内对JSON补丁进行了压缩以后，发现 Json 补丁的大小仍不能接受的，太多的冗余字符了。在我思考了一段时间后，发现可以使用 Json 补丁的数据结构，以二进制数据的形式来消除这些冗余字符，大幅降低补丁的大小，所以二进制补丁的初衷是为了优化 Json 补丁的冗余字符，所以我们将先从 Json 补丁说起。")]),s._v(" "),a("h2",{attrs:{id:"json-补丁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json-补丁"}},[s._v("#")]),s._v(" Json 补丁")]),s._v(" "),a("p",[s._v("Json 补丁中，每个语法节点对象均拥 className 字段以及所有的属性变量。最后由它们的数组一起构成了语法树。")]),s._v(" "),a("h3",{attrs:{id:"最初的-json-补丁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最初的-json-补丁"}},[s._v("#")]),s._v(" 最初的 Json 补丁")]),s._v(" "),a("p",[s._v("示例:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("int a = 1;\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("使用 oc2mangoLib 输出的语法树结构:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('ORDeclareExpression:\n    | ORTypeVarPair: pair\n      | ORTypeSpecial: type\n        | type: TypeInt\n        | name: nil\n      | ORVariable: var\n        | isBlock: NO\n        | ptCount: 0\n        | varname: @"a"\n    | modifier: DeclarationModifierNone\n    | ORValueExpression: expression\n      | value_type: OCValueInt\n      | value: @"1"\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[s._v("未做任何压缩时，生成的最原始的 Json 补丁:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('{\n  "className": "ORDeclareExpression",\n  "pair": {\n    "className": "ORTypeVarPair",\n    "type": {\n      "className": "ORTypeSpecial",\n      "type": 9\n    },\n    "var": {\n      "className": "ORVariable",\n      "ptCount": 0,\n      "varname": "a",\n      "isBlock": 0\n    }\n  }，\n  "modifier": 0,\n  "expression": {\n    "className": "ORValueExpression",\n    "value_type": 10,\n    "value": "1"\n  }\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br")])]),a("p",[s._v("这个时候的补丁确实是清晰易懂的。但是当代码量增大的时候，天灵盖都会被给炸了。")]),s._v(" "),a("p",[s._v("对比一下大小情况:")]),s._v(" "),a("p",[a("code",[s._v("int a = 1;")]),s._v(": 10个字符。")]),s._v(" "),a("p",[s._v("Json 补丁大小:  277字符，直接28倍 -. -。")]),s._v(" "),a("h3",{attrs:{id:"第一次优化补丁大小-使用映射表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一次优化补丁大小-使用映射表"}},[s._v("#")]),s._v(" 第一次优化补丁大小:  使用映射表")]),s._v(" "),a("p",[s._v("观察上一步的 Json 补丁，你就可以发现，数据量的增加主要来源于类名，字段名。")]),s._v(" "),a("p",[s._v("那有没有办法压缩这两个数据并尽量将这两个数据压缩为长度为1的字符串呢？")]),s._v(" "),a("p",[s._v("首先语法树中，节点的类都是已知的，都存在于RunnerClasses.h文件中，并且每个类都有自己的属性列表。")]),s._v(" "),a("p",[s._v("因此我们可以将类名替换为当前类在 RunnerClasses.h 文件中所在序号，属性名替换为属性在类中的序号。")]),s._v(" "),a("p",[s._v("这个压缩过程，可以是一个简单的加解密过程，使用映射表替换就可以了。")]),s._v(" "),a("p",[s._v("加密过程：")]),s._v(" "),a("ol",[a("li",[s._v("将类名替换为类的序号。")]),s._v(" "),a("li",[s._v("将类中的属性名替换为在当前类中的序号。 第一个属性就是0，第二个就是1。")])]),s._v(" "),a("p",[s._v("解密过程：")]),s._v(" "),a("ol",[a("li",[s._v("将类序号转换为类名。")]),s._v(" "),a("li",[s._v("将属性序号转换为当前类的属性名。")])]),s._v(" "),a("p",[a("img",{attrs:{src:e(528),alt:""}})]),s._v(" "),a("p",[s._v("这是将上一步的JSON补丁压缩后的内容:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('{"1":{"n":"3","0":{"n":"1","0":9},"1":{"1":0,"n":"2","2":"a","0":0}},"n":"13","2":{"n":"7","0":10,"1":"1"},"0":0}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[a("strong",[s._v("结果：")])]),s._v(" "),a("ul",[a("li",[s._v("经过这轮压缩，总字符数缩减到了113个，和之前相比，缩小了3倍。")])]),s._v(" "),a("p",[a("strong",[s._v("关于如何生成映射表")]),s._v("：")]),s._v(" "),a("p",[s._v("在 OCRunnerClasses.h 文件中，根据每个类出现的顺序即可生成对应的枚举值，属性的序号值也是同理。具体实现在 "),a("strong",[s._v("GeneralCryptoMapTool.py")]),s._v(" 中，ORPatchFile 中 Json 补丁的加密解密文件 ClassDecryptMap.json 和 ClassEncryptMap.json 都是由它生成的（现在是 ClassSecretKeyMap.h ），"),a("strong",[s._v("GeneralCryptoMapTool.py")]),s._v(" 主要使用的是正则表达式来匹配类和属性，你可以修改其中的代码来实现你自己关于压缩的想法。")]),s._v(" "),a("h3",{attrs:{id:"第二次优化补丁大小-使用字符串表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二次优化补丁大小-使用字符串表"}},[s._v("#")]),s._v(" 第二次优化补丁大小:  使用字符串表")]),s._v(" "),a("p",[a("strong",[s._v("目的:")])]),s._v(" "),a("p",[s._v("解决补丁中字符串的重复使用。")]),s._v(" "),a("p",[a("strong",[s._v("问题:")])]),s._v(" "),a("p",[s._v("如果代码中出现多次为'xxxxxx'的字符串，在补丁中也会出现多次'xxxxxx'的字符串。 当代码量变大时，这会是导致包体积变大的主要因素。")]),s._v(" "),a("p",[a("strong",[s._v("解决办法:")])]),s._v(" "),a("p",[s._v("这个时候突然联想到了 Mach-O 中的字符串表（不知道该不该这么称呼）。有了这个思路，那么这里完全就可以修改为：补丁中有一个数组专用于存放字符串，而在节点中，所有对该字符串的引用，使用's|index'的形式来实现（其实最好是直接使用该字符串在数组中的 index ，但你在 Json 中直接使用 Int 的话，就没法区分这是一个字符串引用了）。")]),s._v(" "),a("p",[a("strong",[s._v("最后结果")]),s._v(":")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// 优化前\n{\n  "nodes": [\n    {"1":0,"n":"2","2":"NSObject","0":0},\n    {"1":0,"n":"2","2":"NSObject","0":0},\n    {"1":0,"n":"2","2":"a","0":0}\n  ]\n}\n\n// 优化后\n{\n  "nodes": [\n    {"1":0,"n":"2","2":"s|0","0":0},\n    {"1":0,"n":"2","2":"s|0","0":0},\n    {"1":0,"n":"2","2":"s|1","0":0}\n  ]\n  "strings": ["NSObject","a"]\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br")])]),a("h3",{attrs:{id:"json-补丁优化后的反思"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json-补丁优化后的反思"}},[s._v("#")]),s._v(" Json 补丁优化后的反思")]),s._v(" "),a("p",[s._v("两次优化以后，使用 oc2mango 中的 TestFiles 进行测试后，发现生成的补丁仍然不能够接受.")]),s._v(" "),a("ol",[a("li",[s._v("源文件大小 38 KB，Json 补丁大小 102 KB，仍然是2.7的样子.")]),s._v(" "),a("li",[s._v("由于补丁文件中 Json 对象和字符串过多，从而使"),a("code",[s._v('{}"":')]),s._v("符号过多重复。这几个符号简直撑起了一片天☁️。")]),s._v(" "),a("li",[s._v("能否将这些无用的符号干掉？能否更好的压缩数据：比如节点类型字段我只想让它占一个字节？这就是实现二进制补丁的起因。")])]),s._v(" "),a("h2",{attrs:{id:"二进制补丁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二进制补丁"}},[s._v("#")]),s._v(" 二进制补丁")]),s._v(" "),a("p",[s._v("🎉欢迎来到二进制补丁，快乐频道（作者哭泣频道）。")]),s._v(" "),a("p",[s._v("二进制补丁就是为了优化 Json 补丁而出现的，主要为了移除 Json 中的"),a("code",[s._v('[]{}:"key')]),s._v("等字符（也算是压缩 Json 吧）。")]),s._v(" "),a("h3",{attrs:{id:"二进制补丁内存布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二进制补丁内存布局"}},[s._v("#")]),s._v(" 二进制补丁内存布局")]),s._v(" "),a("p",[s._v("二进制补丁的核心是将整个语法树转换为全是基础类型数据的内存。")]),s._v(" "),a("p",[s._v("序列化和反序列化的过程，是树的遍历，但是遍历顺序是严格依照结构体成员顺序完成的。")]),s._v(" "),a("p",[s._v("并且每遇见一个节点，节点的基础类型成员需要写入内存或从内存中读取，子节点继续进入这个过程，直至没有子节点。一切都是为了能够完成类似 Json 的内存布局。")]),s._v(" "),a("h4",{attrs:{id:"结构体约定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结构体约定"}},[s._v("#")]),s._v(" 结构体约定:")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("内存对齐值必须为1")])]),s._v(" "),a("li",[a("p",[s._v("第一个字节始终为节点类型")])]),s._v(" "),a("li",[a("p",[s._v("前置所有基本数据类型的结构体成员")])]),s._v(" "),a("li",[a("p",[s._v("每个结构体有一个静态变量，表明该结构体所有基础类型数据的长度: _xxxxNodeBaseLength。")]),s._v(" "),a("p",[s._v("这个变量的作用，主要是为了后续的代码生成，统一结构体对内存的读写。")]),s._v(" "),a("p",[a("img",{attrs:{src:e(529),alt:""}})])])]),s._v(" "),a("h4",{attrs:{id:"又是-int-a-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#又是-int-a-1"}},[s._v("#")]),s._v(" 又是 int a = 1;")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// 同样使用JSON补丁中的例子 int a = 1; 生成的JSON文件\n// 根据结构体的约定，已将JSON数据的顺序调整过\n{"className":"ORDeclareExpression","modifier":0,"pair":{"className":"ORTypeVarPair","type":{"className":"ORTypeSpecial","type":9,"name":null},"var":{"className":"ORVariable","isBlock":0,"ptCount":0,"varname":"a"}},"expression":{"className":"ORValueExpression","value_type":10,"value":"1"}}\n// 移除JSON中的 " 以及 key\n{ORDeclareExpression,0,{ORTypeVarPair,{ORTypeSpecial,9,null},{ORVariable,0,0,"a"}},{ORValueExpression,10,"1"}}\n//这不就是一个结构体吗😂\n//就算出现嵌套，最终它也是一块连续的内存，相当于在栈上的结构体嵌套\n//那把整个语法树拍平了，一样能够放进一块内存\n\n//移除内部的{}后，其实就是补丁文件最终的内存布局\n{ORDeclareExpression,0,ORTypeVarPair,ORTypeSpecial,9,null,ORVariable,0,0,"a",ORValueExpression,10,"1"}\n//替换为_NodeType，内存大小为 41 字节\n{_ORDeclareExpressionNode,0,_ORTypeVarPairNode,_ORTypeSpecialNode,9,null,_ORVariableNode,0,0,"a",_ORValueExpressionNode,10,"1"}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[s._v("他们的结构转换如图所示:")]),s._v(" "),a("p",[a("img",{attrs:{src:e(530),alt:""}})]),s._v(" "),a("p",[s._v("我们将下面这个例子，解释二进制补丁核心的序列化和反序列化。")]),s._v(" "),a("h4",{attrs:{id:"相关的结构体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关的结构体"}},[s._v("#")]),s._v(" 相关的结构体")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 使用预编译的方式实现继承，所有结构体的第一个字节为节点类型\n#define _ORNodeFields \\\nuint8_t nodeType;\n\ntypedef struct {\n    _ORNodeFields\n}_ORNode; // nil\n\ntypedef struct {\n    _ORNodeFields\n    uint32_t modifier;\n    _ORNode * pair;\n    _ORNode * expression;\n}_ORDeclareExpression;\nstatic uint32_t _ORDeclareExpressionBaseLength = 5; // int a = 1\n\ntypedef struct {\n    _ORNodeFields\n    _ORNode * type;\n    _ORNode * var;\n}_ORTypeVarPair;\nstatic uint32_t _ORTypeVarPairBaseLength = 1; // int a\n\ntypedef struct {\n    _ORNodeFields\n    uint32_t type;\n    _StringNode * name;\n}_ORTypeSpecial;\nstatic uint32_t _ORTypeSpecialBaseLength = 5; // int \n\ntypedef struct {\n    _ORNodeFields\n    BOOL isBlock;\n    uint32_t ptCount;\n    _StringNode * varname;\n}_ORVariable;\nstatic uint32_t _ORVariableBaseLength = 6;// a\n\ntypedef struct {\n    _ORNodeFields\n    uint32_t value_type;\n    _ORNode * value;\n}_ORValueExpression; // 1\nstatic uint32_t _ORValueExpressionBaseLength = 5;\n\ntypedef struct {\n    _ORNodeFields\n    uint32_t offset;\n    uint32_t strLen;\n}_StringNode;\nstatic uint32_t _StringNodeBaseLength = 9; // 字符串：变量名等\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br"),a("span",{staticClass:"line-number"},[s._v("49")]),a("br"),a("span",{staticClass:"line-number"},[s._v("50")]),a("br"),a("span",{staticClass:"line-number"},[s._v("51")]),a("br")])]),a("p",[s._v("已知将"),a("code",[s._v("int a = 1;")]),s._v("的语法树转换为结构体表示后，语法树:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('_ORDeclareExpression:\n    | nodeType: _ORDeclareExpressionNode // uint8: 1字节\n    | modifier: 0 // uint32: 4字节\n    | _ORTypeVarPair: pair // _ORNode *\n      | nodeType: _ORTypeVarPairNode // uint8: 1字节\n      | _ORTypeSpecial: type // _ORNode *\n        | nodeType: _ORTypeSpecialNode // uint8: 1字节\n        | type: 9 // uint32: 4字节\n        | name: nil //值为nil时，使用_ORNode结构体（uint8）替换，1字节\n      | _ORVariable: var // _ORNode *\n        | nodeType: _ORVariableNode // uint8: 1字节\n        | isBlock: 0 // BOOL: 1字节\n        | ptCount: 0  // uint32: 4字节\n        | varname: @"a" //值为NSString时，使用_StringNode替换，9字节大小固定\n    | _ORValueExpression: expression // _ORNode *\n      | nodeType: _ORValueExpressionNode // uint8: 1字节\n      | value_type: 10 // uint32:4字节\n      | value: @"1" //值为NSString时，使用_StringNode替换，9字节大小固定\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br")])]),a("p",[s._v("根据上述结果，我们可以计算出"),a("code",[s._v("int a = 1")]),s._v("在二进制补丁中的大小为41字节。")]),s._v(" "),a("p",[a("strong",[s._v("最终目标:")])]),s._v(" "),a("p",[s._v("在一块41字节大小的内存中，存储的数据需要如下")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("//将nil和NSString替换为_ORNode和_StringNode后\n{_ORDeclareExpressionNode,0,_ORTypeVarPairNode,_ORTypeSpecialNode,9,ORNodeType,_ORVariableNode,0,0,StringNodeType,0,0,_ORValueExpressionNode,10,StringNodeType,0,0}\n//冒号后的是字节大小\n{\n_ORDeclareExpressionNode: 1,\n0: 4,\n_ORTypeVarPairNode: 1,\n_ORTypeSpecialNode: 1,\n9: 4,\nORNodeType: 1,\n_ORVariableNode: 1,\n0: 1,\n0: 4,\nStringNodeType: 1,\n0: 4,\n0: 4,\n_ORValueExpressionNode: 1,\n10: 4,\nStringNodeType: 1,\n0: 4,\n0: 4\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br")])]),a("p",[s._v("为了完成上述目标，"),a("code",[s._v("int a = 1;")]),s._v("语法树的序列化代码如下:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 其实每个结构体的基本类型数据的读/写都是一样的，只是命名不同而已\n// 如果有一个针对节点进行汇总处理的函数，这些代码是完全可以自动生成的\n\n_ORDeclareExpression *declareExpNode;\nvoid *buffer = malloc(41);\nuint32_t cursor = 0;\n//将_ORDeclareExpression的基本类型数据复制到内存中\nmemcpy(buffer, declareExpNode, _ORDeclareExpressionBaseLength);\n//设置buffer的偏移量\ncursor += _ORDeclareExpressionBaseLength; // cursor = 0 + 5 = 5\n//buffer的[0,1)字节的值为_ORDeclareExpressionNode: uint8\n//buffer的[1,5)字节的值为0: uint32\n\n{\n  _ORTypeVarPair *varPair = declareExpNode->pair;\n  memcpy(buffer + cursor, varPair, _ORTypeVarPairBaseLength);\n  cursor += _ORTypeVarPairBaseLength; // cursor = 5 + 1 = 6\n  //buffer的[5,6)字节的值为_ORTypeVarPairNode: uint8\n\n  _ORTypeSpecial *typeSpecail = varPair->type;\n  memcpy(buffer + cursor, typeSpecail, _ORTypeSpecialBaseLength);\n  cursor += _ORTypeSpecialBaseLength; // cursor = 6 + 5 = 11\n  //buffer的[6,7)字节的值为_ORTypeSpecialNode: uint8\n  //buffer的[7,11)字节的值为9: uint32\n\n  _ORNode *typeName = varPair->name;\n  memcpy(buffer + cursor, typeSpecail, _ORNodeBaseLength);\n  cursor += _ORNodeBaseLength; // cursor = 11 + 1 = 12\n  //buffer的[11,12)字节的值为ORNodeType: uint8\n  \n  {\n      _ORVariable *variable = varPair->var;\n   \t\tmemcpy(buffer + cursor, variable, _ORVariableBaseLength);\n\t    cursor += _ORVariableBaseLength; // cursor = 12 + 6 = 18\n      //buffer的[12,13)字节的值为_ORVariableNode: uint8\n      //buffer的[13,14)字节的值为0: BOOL\n      //buffer的[14,18)字节的值为0: uint32\n\n      _StringNode *variableName = variable->varname;\n      memcpy(buffer + cursor, variableName, _StringNodeBaseLength);\n      cursor += _StringNodeBaseLength;// cursor = 18 + 9 = 27\n      //buffer的[18,19)字节的值为StringNodeType: uint8\n      //buffer的[19,23)字节的值为0: uint32\n      //buffer的[23,27)字节的值为0: uint32\n  }\n}\n\n{\n  _ORValueExpression *vlaueExp = declareExpNode->expression;\n  memcpy(buffer + cursor, vlaueExp, _ORVariableBaseLength);\n  cursor += _ORVariableBaseLength;// cursor = 27 + 5 = 32\n  //buffer的[27,28)字节的值为_ORValueExpression: uint8\n  //buffer的[28,32)字节的值为10: uint32\n\n  _StringNode *stringNode = vlaueExp->value;\n  memcpy(buffer + cursor, variable, _StringNodeBaseLength);\n  cursor += _StringNodeBaseLength;// cursor = 32 + 9 = 41\n  //buffer的[32,33)字节的值为StringNodeType: uint8\n  //buffer的[33,37)字节的值为0: uint32\n  //buffer的[37,41)字节的值为0: uint32\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br"),a("span",{staticClass:"line-number"},[s._v("49")]),a("br"),a("span",{staticClass:"line-number"},[s._v("50")]),a("br"),a("span",{staticClass:"line-number"},[s._v("51")]),a("br"),a("span",{staticClass:"line-number"},[s._v("52")]),a("br"),a("span",{staticClass:"line-number"},[s._v("53")]),a("br"),a("span",{staticClass:"line-number"},[s._v("54")]),a("br"),a("span",{staticClass:"line-number"},[s._v("55")]),a("br"),a("span",{staticClass:"line-number"},[s._v("56")]),a("br"),a("span",{staticClass:"line-number"},[s._v("57")]),a("br"),a("span",{staticClass:"line-number"},[s._v("58")]),a("br"),a("span",{staticClass:"line-number"},[s._v("59")]),a("br"),a("span",{staticClass:"line-number"},[s._v("60")]),a("br"),a("span",{staticClass:"line-number"},[s._v("61")]),a("br")])]),a("p",[s._v("反序列化就是上面的反向操作了")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("//1.直接获取内存当前位置的第一个字节，用于判断节点类型\n//2.根据节点类型，进入相关结构体的反序列化函数\n//3.根据节点的基本类型数据的长度，从内存中读取相应长度的数据，增加游标\n//4.根据所有子节点的顺序，依次回到第一步 (什么是子节点？类型是_ORNode *的结构体成员就是子节点了)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("序列化：最后使用写入完成后的buffer初始化NSData，并将NSData写入到文件即可。")]),s._v(" "),a("p",[s._v("反序列化:  用NSData加载文件，并使用bytes生成_ORPatchFile。")]),s._v(" "),a("h3",{attrs:{id:"代码生成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码生成"}},[s._v("#")]),s._v(" 代码生成")]),s._v(" "),a("p",[a("strong",[s._v("BinaryPatchHelper.h/.m")]),s._v(" 中的代码，除去**_ORNode, _ListNode, _StringsNode, _StringNode, _PatchNode**和相关函数外，其余代码皆由 "),a("strong",[s._v("BinaryPatchCodeGenerator")]),s._v(" 生成。")]),s._v(" "),a("p",[a("strong",[s._v("BinaryPatchCodeGenerator")]),s._v(" 使用 "),a("strong",[s._v("oc2mangoLib")]),s._v(" 将 "),a("strong",[s._v("RunnerClasses.h")]),s._v(" 解析为语法树，根据文件存在的类，生成相应的结构体代码，以及 转换、反转换、序列化、反序列化和销毁，一共5个函数。并且针对类型为NSUInteger、NSArray、NSString的属性，分别转换为 uint32_t、_ListNode 和 _StringNode。")]),s._v(" "),a("p",[s._v("参照如下例子:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('@interface ORTypeSpecial: ORNode\n@property (nonatomic, assign) TypeKind type;\n@property (nonatomic, nullable, copy) NSString * name;\n@end\n//结构体名："_" + 类名\n//结构体基础类型字段总和长度："_" + 类名 + "BaseLength"\n//字段数量和名字：和类中的属性完全相同\ntypedef struct {\n    _ORNodeFields\n    uint32_t type;\n    _StringNode * name;\n}_ORTypeSpecial;\nstatic uint32_t _ORTypeSpecialBaseLength = 5;\n_ORTypeSpecial *_ORTypeSpecialConvert(ORTypeSpecial *exp, _PatchNode *patch, uint32_t *length);\nORTypeSpecial *_ORTypeSpecialDeConvert(_ORTypeSpecial *node, _PatchNode *patch);\nvoid _ORTypeSpecialSerailization(_ORTypeSpecial *node, void *buffer, uint32_t *cursor);\n_ORTypeSpecial *_ORTypeSpecialDeserialization(void *buffer, uint32_t *cursor, uint32_t bufferLength);\nvoid _ORTypeSpecialDestroy(_ORTypeSpecial *node);\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br")])]),a("p",[s._v("下列约定，主要用于序列化和反序列化的代码生成。")]),s._v(" "),a("h4",{attrs:{id:"节点序列化约定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点序列化约定"}},[s._v("#")]),s._v(" 节点序列化约定:")]),s._v(" "),a("p",[s._v("每个节点结构体的序列化函数，使用BaseLength值，将所有的基础类型的数据写入buffer。子节点的序列化同样使用这个规则。")]),s._v(" "),a("ul",[a("li",[s._v("每个结构体需实现自身的序列化函数")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("void \\(structName)Serailization(\\(structName) *node, void *buffer, uint32_t *cursor)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("ul",[a("li",[s._v("将所有基础类型数据写入内存时，采用如下方式")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("memcpy(buffer + *cursor, node, \\(structName)BaseLength);\n*cursor += \\(structName)BaseLength;\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("针对复合类型字段，需要严格按照结构体成员的顺序写入内存。")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("typedef struct {\n    _ORNodeFields\n    _ORNode * type;\n    _ORNode * var;\n}_ORTypeVarPair;\nstatic uint32_t _ORTypeVarPairBaseLength = 1;\nvoid _ORTypeVarPairSerailization(_ORTypeVarPair *node, void *buffer, uint32_t *cursor){\n    memcpy(buffer + *cursor, node, _ORTypeVarPairBaseLength);\n    *cursor += _ORTypeVarPairBaseLength;\n    _ORNodeSerailization((_ORNode *)node->type, buffer, cursor);\n    _ORNodeSerailization((_ORNode *)node->var, buffer, cursor);\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("ul",[a("li",[s._v("使用统一的入口，将结构体的基础类型数据写入内存。根据类型对应的结构体，使用该结构体的序列化函数")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("void _ORNodeSerailization(_ORNode *node, void *buffer, uint32_t *cursor){\n\t  if (node->nodeType == ORNodeType) {\n        memcpy(buffer + *cursor, node, \\(_ORNodeLength));\n        *cursor += \\(_ORNodeLength);\n  \t}else if\n  \t...\n  \t//各个节点类型判断，根据类型使用相应的序列化函数\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h4",{attrs:{id:"节点反序列化约定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点反序列化约定"}},[s._v("#")]),s._v(" 节点反序列化约定:")]),s._v(" "),a("p",[s._v("每个节点结构体的反序列化函数，使用BaseLength值，从buffer中读取所有的基础类型的数据，然后复制到结构体中。子节点的反序列化同样使用这个规则。")]),s._v(" "),a("ul",[a("li",[s._v("每个结构体需实现自身的反序列化函数")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("\\(structName) *\\(structName)Deserialization(void *buffer, uint32_t *cursor, uint32_t bufferLength)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("ul",[a("li",[s._v("从内存中将所有的基本类型数据保存到结构体时，采用如下方式")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("\\(structName) *node = malloc(sizeof(\\(structName)));\nmemcpy(node, buffer + *cursor, \\(structName)BaseLength);\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("针对复合类型字段，需要严格按照结构体成员的顺序从内存中读取。")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("typedef struct {\n    _ORNodeFields\n    _ORNode * type;\n    _ORNode * var;\n}_ORTypeVarPair;\nstatic uint32_t _ORTypeVarPairBaseLength = 1;\n_ORTypeVarPair *_ORTypeVarPairDeserialization(void *buffer, uint32_t *cursor, uint32_t bufferLength){\n    _ORTypeVarPair *node = malloc(sizeof(_ORTypeVarPair));\n    memcpy(node, buffer + *cursor, _ORTypeVarPairBaseLength);\n    *cursor += _ORTypeVarPairBaseLength;\n    node->type =(_ORNode *) _ORNodeDeserialization(buffer, cursor, bufferLength);\n    node->var =(_ORNode *) _ORNodeDeserialization(buffer, cursor, bufferLength);\n    return node;\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("ul",[a("li",[s._v("使用统一的入口，将结构体的基础类型数据写入内存。根据类型对应的结构体，使用该结构体的序列化函数")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("_ORNode *_ORNodeDeserialization(void *buffer, uint32_t *cursor, uint32_t bufferLength){\n \t  _NodeType nodeType = ORNodeType;\n    if (*cursor < bufferLength) {\n        nodeType = *(_NodeType *)(buffer + *cursor);\n    }\n  \t...\n  \t//各个节点类型判断，根据类型使用相应的反序列化函数\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h3",{attrs:{id:"自定义的结构体"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义的结构体"}},[s._v("#")]),s._v(" 自定义的结构体")]),s._v(" "),a("h4",{attrs:{id:"ornode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ornode"}},[s._v("#")]),s._v(" _ORNode")]),s._v(" "),a("p",[s._v("所有节点结构体都继承自**_ORNode**结构体，在内存中，第一个字节的数据，始终是类型字段nodeType: "),a("strong",[s._v("_NodeType")]),s._v("枚举列表。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("#define _ORNodeFields \\\nuint8_t nodeType;\n\n//继承是使用预编译实现\ntypedef struct {\n    _ORNodeFields\n}_ORNode;\nstatic uint32_t _ORNodeLength = 1;\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h4",{attrs:{id:"stringsnode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stringsnode"}},[s._v("#")]),s._v(" _StringsNode")]),s._v(" "),a("p",[s._v("与JSON补丁中的字符串表类似，但**_StringsNode**结构体不再是一个数组，它拥有一块内存，用来存储所有的字符串，同时它还有这块内存的大小的字段。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("typedef struct {\n    _ORNodeFields\n    uint32_t cursor;\n    char *buffer;\n}_StringsNode;\nstatic uint32_t _StringsNodeBaseLength = 5;\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h4",{attrs:{id:"stringnode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stringnode"}},[s._v("#")]),s._v(" _StringNode")]),s._v(" "),a("p",[s._v("与**_StringsNode"),a("strong",[s._v("相配合使用，用于在")]),s._v("_StringsNode->buffer**中，直接定位并获取相应长度的字符串。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// StringNode是对NSString的转换。\ntypedef struct {\n    _ORNodeFields\n    uint32_t offset;\n    uint32_t strLen;\n}_StringNode;\nstatic uint32_t _StringNodeBaseLength = 9;\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("使用**_StringNode**获取字符串，如下代码：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('StringNode node = { StringNodeType, 3, 8 };\nStringsNode table = {StringsNodeType, 11, "ABCNSObject"};\nNSString *result = stringsNodeGetString(table, node);\nresult = @"NSObject";\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("在内存中的操作，如图所示:")]),s._v(" "),a("p",[a("img",{attrs:{src:e(531),alt:""}})]),s._v(" "),a("h4",{attrs:{id:"listnode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#listnode"}},[s._v("#")]),s._v(" _ListNode")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// _ListNode是对NSArray的转换。\ntypedef struct {\n    _ORNodeFields\n    uint32_t count;\n    _ORNode **nodes;\n}_ListNode;\nstatic uint32_t _ListNodeBaseLength = 5;\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("h4",{attrs:{id:"patchnode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#patchnode"}},[s._v("#")]),s._v(" _PatchNode")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// _PatchNode是对ORPatchFile的转换。\ntypedef struct {\n    _ORNodeFields\n    BOOL enable;\n    _StringsNode *strings;\n    _StringNode *appVersion;\n    _StringNode *osVersion;\n    _ListNode *nodes;\n}_PatchNode;\nstatic uint32_t _PatchNodeBaseLength = 2;\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("其他所有结构体相关代码，皆由"),a("strong",[s._v("BinaryPatchCodeGenerator")]),s._v("生成")]),s._v(" "),a("h2",{attrs:{id:"大小端问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大小端问题"}},[s._v("#")]),s._v(" 大小端问题")]),s._v(" "),a("p",[s._v("经测试，macos和iOS均是小端模式，放心使用即可。")]),s._v(" "),a("h2",{attrs:{id:"结尾"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结尾"}},[s._v("#")]),s._v(" 结尾")]),s._v(" "),a("p",[s._v("说实话，这篇文章差点把我写哭泣，思路真不好理，很多地方我都不知道怎么表达。")]),s._v(" "),a("p",[s._v("大伙们将就着看吧。")])])}),[],!1,null,null,null);n.default=t.exports}}]);